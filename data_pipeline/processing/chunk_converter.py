"""Integration layer converting SAC output to storage layer Chunk format."""

from typing import Optional
import logging
from storage.vector.base import Chunk, ChunkMetadata
from .summary_augmented_chunker import DocumentInfo

logger = logging.getLogger(__name__)


def create_embedding_stub(size: int = 1536) -> list[float]:
    """Create a stub embedding (zeros).
    
    The actual embedding will be generated by the embedder before storage.
    
    Args:
        size: Embedding dimension (default for many models is 1536)
        
    Returns:
        List of zeros with specified size
    """
    return [0.0] * size


def sac_chunk_to_storage_chunk(
    sac_chunk: dict,
    embedding: Optional[list[float]] = None,
    embedding_size: int = 1536
) -> Chunk:
    """Convert SAC output to storage layer Chunk.
    
    Args:
        sac_chunk: Output from SummaryAugmentedChunker.chunk_document()
        embedding: Pre-computed embedding (if None, uses stub)
        embedding_size: Size of embedding vector
        
    Returns:
        Chunk object compatible with VectorStore
    """
    metadata_dict = sac_chunk["metadata"]
    
    # Clean up metadata for ChunkMetadata (filter out extra fields)
    chunk_metadata = ChunkMetadata(
        source=metadata_dict.get("source", "Unknown"),
        part=metadata_dict.get("part", ""),
        section=metadata_dict.get("section", ""),
        topic=metadata_dict.get("topic", "General"),
        url=metadata_dict.get("url", ""),
        parent_section=metadata_dict.get("parent_section"),
        hierarchy_level=metadata_dict.get("hierarchy_level", 0)
    )
    
    chunk = Chunk(
        id=sac_chunk["id"],
        document_id=metadata_dict.get("source", "unknown"),
        content=sac_chunk["augmented_content"],  # Use augmented (with summary)
        summary=sac_chunk["summary"],
        embedding=embedding or create_embedding_stub(embedding_size),
        metadata=chunk_metadata
    )
    
    logger.debug(f"Created storage chunk {chunk.id} from section {chunk_metadata.section}")
    return chunk


def sac_chunks_to_storage_chunks(
    sac_chunks: list[dict],
    embeddings: Optional[list[list[float]]] = None,
    embedding_size: int = 1536
) -> list[Chunk]:
    """Convert batch of SAC chunks to storage layer Chunks.
    
    Args:
        sac_chunks: List of outputs from SummaryAugmentedChunker
        embeddings: Pre-computed embeddings (if None, uses stubs)
        embedding_size: Size of embedding vectors
        
    Returns:
        List of Chunk objects
    """
    if embeddings and len(embeddings) != len(sac_chunks):
        logger.warning(
            f"Embedding count ({len(embeddings)}) doesn't match chunk count ({len(sac_chunks)}). "
            "Using stubs for missing embeddings."
        )
    
    storage_chunks = []
    for i, sac_chunk in enumerate(sac_chunks):
        embedding = embeddings[i] if embeddings and i < len(embeddings) else None
        chunk = sac_chunk_to_storage_chunk(sac_chunk, embedding, embedding_size)
        storage_chunks.append(chunk)
    
    logger.info(f"Converted {len(sac_chunks)} SAC chunks to storage format")
    return storage_chunks
